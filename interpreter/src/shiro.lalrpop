use std::str::FromStr;
use crate::ast::{Expr, Opcode, IfBranch, AssignOpcode};

grammar;

pub Chunk: Vec<Box<Expr>> = {
    <mut c:Chunk> <l:Stmt> => { if &*l != &Expr::Nop { c.push(l); } c },
    <l:Stmt> => if &*l != &Expr::Nop { vec![l] } else { vec![] }
};

Stmt: Box<Expr> = {
    "fun" <name:Identifier> "(" <args:ArgsDef> ")" "{" <b:Chunk> "}" => Box::new(Expr::Fun(Some(name), args, b)),
    "fun" <name:Identifier> "(" ")" "{" <b:Chunk> "}" => Box::new(Expr::Fun(Some(name), vec![], b)), 
    "while" <e:Expr> "{" <c:Chunk> "}" => Box::new(Expr::While(e, c)),
    "for" <i:Expr> ";" <c:Expr> ";" <a:Expr> "{" <b:Chunk> "}" => Box::new(Expr::For(i, c, a, b)),
    "return" <retval:Expr> ";" => Box::new(Expr::Return(retval)),
    <br:IfBranches> => Box::new(Expr::If(br)),
    ";" => Box::new(Expr::Nop),
    <e:Expr> ";" => e
};

// Expressions
Expr: Box<Expr> = {
    "fun" "(" <args:ArgsDef> ")" "{" <b:Chunk> "}" => Box::new(Expr::Fun(None, args, b)),
    "fun" "(" ")" "{" <b:Chunk> "}" => Box::new(Expr::Fun(None, vec![], b)),
    "let" <name:Identifier> "=" <val:Expr> => Box::new(Expr::Let(name, val)),
    <r:Reference> "+=" <v:Cmp> => Box::new(Expr::AssignOp(r, AssignOpcode::Add, v)),
    <r:Reference> "-=" <v:Cmp> => Box::new(Expr::AssignOp(r, AssignOpcode::Sub, v)),
    <r:Reference> "=" <v:Cmp> => Box::new(Expr::AssignOp(r, AssignOpcode::Eq, v)),
    Cmp
}

IfBranches: Vec<Box<IfBranch>> = {
    "if" <e:IfBlock> => vec![e],
    <mut v:IfBranches> "else if" <e:IfBlock> => { v.push(e); v },
    <mut v:IfBranches> "else" "{" <b:Chunk> "}" => { v.push(Box::new(IfBranch{ condition: None, body: b })); v },
}

IfBlock: Box<IfBranch> = {
    <c:Expr> "{" <b:Chunk> "}" => Box::new(IfBranch{ condition:Some(c), body:b }),
}

Cmp: Box<Expr> = {
    Cmp CmpOp Sum => Box::new(Expr::Op(<>)),
    Sum
}

CmpOp: Opcode = {
    "!=" => Opcode::Neq,
    "==" => Opcode::Eq,
    ">" => Opcode::Gt,
    ">=" => Opcode::Gte,
    "<" => Opcode::Lt,
    "<=" => Opcode::Lte,
};

Sum: Box<Expr> = {
    Sum SumOp Factor => Box::new(Expr::Op(<>)),
    Factor,
};

SumOp: Opcode = {
    "+" => Opcode::Add,
    "-" => Opcode::Sub,
};

Factor: Box<Expr> = {
    Factor FactorOp Term => Box::new(Expr::Op(<>)),
    Term,
};

FactorOp: Opcode = {
    "*" => Opcode::Mul,
    "/" => Opcode::Div,
    "%" => Opcode::Mod,
};

Term: Box<Expr> = {
    "null" => Box::new(Expr::Null),
    Integer => Box::new(Expr::Integer(<>)),
    Decimal => Box::new(Expr::Decimal(<>)),
    Str => Box::new(Expr::String(<>)),
    Boolean => Box::new(Expr::Boolean(<>)),
    Reference => Box::new(Expr::Reference(<>)),
    <n:Reference> "(" <args:Args> ")" => Box::new(Expr::Invocation(n, args)),
    <n:Reference> "(" ")" => Box::new(Expr::Invocation(n, vec![])),
    <r:Reference> "[" <i:Expr> "]" => Box::new(Expr::IndexedReference(r, i)),
    "(" <Expr> ")",
    "{" <o:ShionObject> "}" => Box::new(Expr::ShionObject(o)),
    "[" <a:Args> "]" => Box::new(Expr::ShionArray(a)),
};

// SHION
ShionObject: Vec<Box<Expr>> = {
    <e:ShionDef> => vec![e],
    <mut v:ShionObject> "," <e:ShionDef> => { v.push(e); v },
};

ShionDef: Box<Expr> = {
    <i:Identifier> "=" <e:Expr> => Box::new(Expr::ShionDef(i, e))
};

// Primitives
Args: Vec<Box<Expr>> = {
    <e:Expr> => vec![e],
    <mut v:Args> "," <e:Expr> => { v.push(e); v },
}

ArgsDef: Vec<String> = {
    <mut c:ArgsDef> "," <i:Identifier> => { c.push(i); c },
    <i:Identifier> => vec![i],
}

Reference: Vec<String> = {
    <mut c:Reference> "." <i:Identifier> => { c.push(i); c },
    <i:Identifier> => vec![i],
};

Integer: i32 = {
    r"[-]{0,1}[0-9]+" => i32::from_str(<>).unwrap(),
};

Decimal: f32 = {
    r"[-]{0,1}[0-9]+\.[0-9]+" => f32::from_str(&<>[..1]).unwrap(),
}

Str: String = {
    r"'[^']*'" => <>.trim_matches('\'').to_string()
};

Boolean: bool = {
    "true" => true,
    "false" => false,
};

Identifier: String = {
    r"[A-Za-z_]{1}[A-Za-z0-9_]*" => <>.to_string()
};