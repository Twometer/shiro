use std::str::FromStr;
use crate::ast::{Expr, Opcode};

grammar;

pub Chunk: Vec<Box<Expr>> = {
    <mut c:Chunk> <l:Line> => { if &*l != &Expr::Nop { c.push(l); } c },
    <l:Line> => if &*l != &Expr::Nop { vec![l] } else { vec![] }
};

Line: Box<Expr> = {
    ";" => Box::new(Expr::Nop),
    <e:Expr> ";" => e
};

// Expressions
Expr: Box<Expr> = {
    "let" <name:Identifier> "=" <val:Expr> => Box::new(Expr::Let(name, val)),
    <r:Reference> "=" <v:Cmp> => Box::new(Expr::Assignment(r, v)),
    Cmp
}

Cmp: Box<Expr> = {
    Cmp CmpOp Sum => Box::new(Expr::Op(<>)),
    Sum
}

CmpOp: Opcode = {
    "!=" => Opcode::Neq,
    "==" => Opcode::Eq,
    ">" => Opcode::Gt,
    ">=" => Opcode::Gte,
    "<" => Opcode::Lt,
    "<=" => Opcode::Lte,
};

Sum: Box<Expr> = {
    Sum SumOp Factor => Box::new(Expr::Op(<>)),
    Factor,
};

SumOp: Opcode = {
    "+" => Opcode::Add,
    "-" => Opcode::Sub,
};

Factor: Box<Expr> = {
    Factor FactorOp Term => Box::new(Expr::Op(<>)),
    Term,
};

FactorOp: Opcode = {
    "*" => Opcode::Mul,
    "/" => Opcode::Div,
    "%" => Opcode::Mod,
};

Term: Box<Expr> = {
    "null" => Box::new(Expr::Null),
    Number => Box::new(Expr::Number(<>)),
    Str => Box::new(Expr::String(<>)),
    Boolean => Box::new(Expr::Boolean(<>)),
    Reference => Box::new(Expr::Reference(<>)),
    <n:Reference> "(" <args:Args> ")" => Box::new(Expr::Invocation(n, args)),
    <n:Reference> "(" ")" => Box::new(Expr::Invocation(n, vec![])),
    "(" <Expr> ")",
    "{" <o:ShionObject> "}" => Box::new(Expr::ShionObject(o)),
    "[" <a:Args> "]" => Box::new(Expr::ShionArray(a)),
};

// SHION
ShionObject: Vec<Box<Expr>> = {
    <e:ShionDef> => vec![e],
    <mut v:ShionObject> "," <e:ShionDef> => { v.push(e); v },
};

ShionDef: Box<Expr> = {
    <i:Identifier> "=" <e:Expr> => Box::new(Expr::ShionDef(i, e))
};

// Primitives
Args: Vec<Box<Expr>> = {
    <e:Expr> => vec![e],
    <mut v:Args> "," <e:Expr> => { v.push(e); v },
}

Reference: Vec<String> = {
    <mut c:Reference> "." <i:Identifier> => { c.push(i); c },
    <i:Identifier> => vec![i],
};

Number: f32 = {
    r"[-]{0,1}[0-9]+\.[0-9]+[Ff]" => f32::from_str(&<>[..1]).unwrap(),
    r"[-]{0,1}[0-9]+" => f32::from_str(<>).unwrap(),
};

Str: String = {
    r"'[^']*'" => <>.trim_matches('\'').to_string()
};

Boolean: bool = {
    "true" => true,
    "false" => false,
};

Identifier: String = {
    r"[A-Za-z_]{1}[A-Za-z0-9_]*" => <>.to_string()
};